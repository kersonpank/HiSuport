{"ast":null,"code":"import * as t from \"react\";\nfunction n() {\n  return n = Object.assign ? Object.assign.bind() : function (t) {\n    for (var n = 1; n < arguments.length; n++) {\n      var e = arguments[n];\n      for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n    }\n    return t;\n  }, n.apply(this, arguments);\n}\nconst e = [\"children\", \"options\"],\n  r = [\"allowFullScreen\", \"allowTransparency\", \"autoComplete\", \"autoFocus\", \"autoPlay\", \"cellPadding\", \"cellSpacing\", \"charSet\", \"className\", \"classId\", \"colSpan\", \"contentEditable\", \"contextMenu\", \"crossOrigin\", \"encType\", \"formAction\", \"formEncType\", \"formMethod\", \"formNoValidate\", \"formTarget\", \"frameBorder\", \"hrefLang\", \"inputMode\", \"keyParams\", \"keyType\", \"marginHeight\", \"marginWidth\", \"maxLength\", \"mediaGroup\", \"minLength\", \"noValidate\", \"radioGroup\", \"readOnly\", \"rowSpan\", \"spellCheck\", \"srcDoc\", \"srcLang\", \"srcSet\", \"tabIndex\", \"useMap\"].reduce((t, n) => (t[n.toLowerCase()] = n, t), {\n    for: \"htmlFor\"\n  }),\n  o = {\n    amp: \"&\",\n    apos: \"'\",\n    gt: \">\",\n    lt: \"<\",\n    nbsp: \" \",\n    quot: \"“\"\n  },\n  c = [\"style\", \"script\"],\n  a = /([-A-Z0-9_:]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|(?:\\{((?:\\\\.|{[^}]*?}|[^}])*)\\})))?/gi,\n  _ = /mailto:/i,\n  u = /\\n{2,}$/,\n  i = /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/,\n  s = /^ *> ?/gm,\n  l = /^ {2,}\\n/,\n  f = /^(?:( *[-*_])){3,} *(?:\\n *)+\\n/,\n  d = /^\\s*(`{3,}|~{3,}) *(\\S+)?([^\\n]*?)?\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)*\\n?/,\n  p = /^(?: {4}[^\\n]+\\n*)+(?:\\n *)+\\n?/,\n  m = /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\n  g = /^(?:\\n *)*\\n/,\n  y = /\\r\\n?/g,\n  h = /^\\[\\^([^\\]]+)](:.*)\\n/,\n  k = /^\\[\\^([^\\]]+)]/,\n  x = /\\f/g,\n  b = /^\\s*?\\[(x|\\s)\\]/,\n  $ = /^ *(#{1,6}) *([^\\n]+?)(?: +#*)?(?:\\n *)*(?:\\n|$)/,\n  v = /^ *(#{1,6}) +([^\\n]+?)(?: +#*)?(?:\\n *)*(?:\\n|$)/,\n  S = /^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/,\n  z = /^ *(?!<[a-z][^ >/]* ?\\/>)<([a-z][^ >/]*) ?([^>]*)\\/{0}>\\n?(\\s*(?:<\\1[^>]*?>[\\s\\S]*?<\\/\\1>|(?!<\\1)[\\s\\S])*?)<\\/\\1>\\n*/i,\n  w = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi,\n  A = /^<!--[\\s\\S]*?(?:-->)/,\n  E = /^(data|aria|x)-[a-z_][a-z\\d_.-]*$/,\n  L = /^ *<([a-z][a-z0-9:]*)(?:\\s+((?:<.*?>|[^>])*))?\\/?>(?!<\\/\\1>)(\\s*\\n)?/i,\n  M = /^\\{.*\\}$/,\n  O = /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n  I = /^<([^ >]+@[^ >]+)>/,\n  j = /^<([^ >]+:\\/[^ >]+)>/,\n  B = /-([a-z])?/gi,\n  R = /^(.*\\|?.*)\\n *(\\|? *[-:]+ *\\|[-| :]*)\\n((?:.*\\|.*\\n)*)\\n?/,\n  T = /^\\[([^\\]]*)\\]:\\s+<?([^\\s>]+)>?\\s*(\"([^\"]*)\")?/,\n  C = /^!\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/,\n  D = /^\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/,\n  F = /(\\[|\\])/g,\n  N = /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/,\n  P = /\\t/g,\n  Z = /^ *\\| */,\n  G = /(^ *\\||\\| *$)/g,\n  H = / *$/,\n  q = /^ *:-+: *$/,\n  U = /^ *:-+ *$/,\n  V = /^ *-+: *$/,\n  W = /^([*_])\\1((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1\\1(?!\\1)/,\n  Q = /^([*_])((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1(?!\\1|\\w)/,\n  X = /^==((?:\\[.*?\\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)==/,\n  J = /^~~((?:\\[.*?\\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)~~/,\n  K = /^\\\\([^0-9A-Za-z\\s])/,\n  Y = /^[\\s\\S]+?(?=[^0-9A-Z\\s\\u00c0-\\uffff&#;.()'\"]|\\d+\\.|\\n\\n| {2,}\\n|\\w+:\\S|$)/i,\n  tt = /^\\n+/,\n  nt = /^([ \\t]*)/,\n  et = /\\\\([^\\\\])/g,\n  rt = / *\\n+$/,\n  ot = /(?:^|\\n)( *)$/,\n  ct = \"(?:\\\\d+\\\\.)\",\n  at = \"(?:[*+-])\";\nfunction _t(t) {\n  return \"( *)(\" + (1 === t ? ct : at) + \") +\";\n}\nconst ut = _t(1),\n  it = _t(2);\nfunction st(t) {\n  return new RegExp(\"^\" + (1 === t ? ut : it));\n}\nconst lt = st(1),\n  ft = st(2);\nfunction dt(t) {\n  return new RegExp(\"^\" + (1 === t ? ut : it) + \"[^\\\\n]*(?:\\\\n(?!\\\\1\" + (1 === t ? ct : at) + \" )[^\\\\n]*)*(\\\\n|$)\", \"gm\");\n}\nconst pt = dt(1),\n  mt = dt(2);\nfunction gt(t) {\n  const n = 1 === t ? ct : at;\n  return new RegExp(\"^( *)(\" + n + \") [\\\\s\\\\S]+?(?:\\\\n{2,}(?! )(?!\\\\1\" + n + \" (?!\" + n + \" ))\\\\n*|\\\\s*\\\\n*$)\");\n}\nconst yt = gt(1),\n  ht = gt(2);\nfunction kt(t, n) {\n  const e = 1 === n,\n    r = e ? yt : ht,\n    o = e ? pt : mt,\n    c = e ? lt : ft;\n  return {\n    t(t, n, e) {\n      const o = ot.exec(e);\n      return o && (n.o || !n._ && !n.u) ? r.exec(t = o[1] + t) : null;\n    },\n    i: Ht.HIGH,\n    l(t, n, r) {\n      const a = e ? +t[2] : void 0,\n        _ = t[0].replace(u, \"\\n\").match(o);\n      let i = !1;\n      return {\n        p: _.map(function (t, e) {\n          const o = c.exec(t)[0].length,\n            a = new RegExp(\"^ {1,\" + o + \"}\", \"gm\"),\n            u = t.replace(a, \"\").replace(c, \"\"),\n            s = e === _.length - 1,\n            l = -1 !== u.indexOf(\"\\n\\n\") || s && i;\n          i = l;\n          const f = r._,\n            d = r.o;\n          let p;\n          r.o = !0, l ? (r._ = !1, p = u.replace(rt, \"\\n\\n\")) : (r._ = !0, p = u.replace(rt, \"\"));\n          const m = n(p, r);\n          return r._ = f, r.o = d, m;\n        }),\n        m: e,\n        g: a\n      };\n    },\n    h: (n, e, r) => t(n.m ? \"ol\" : \"ul\", {\n      key: r.k,\n      start: n.g\n    }, n.p.map(function (n, o) {\n      return t(\"li\", {\n        key: o\n      }, e(n, r));\n    }))\n  };\n}\nconst xt = /^\\[([^\\]]*)]\\( *((?:\\([^)]*\\)|[^() ])*) *\"?([^)\"]*)?\"?\\)/,\n  bt = /^!\\[([^\\]]*)]\\( *((?:\\([^)]*\\)|[^() ])*) *\"?([^)\"]*)?\"?\\)/,\n  $t = [i, d, p, $, S, v, A, R, pt, yt, mt, ht],\n  vt = [...$t, /^[^\\n]+(?:  \\n|\\n{2,})/, z, L];\nfunction St(t) {\n  return t.replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g, \"a\").replace(/[çÇ]/g, \"c\").replace(/[ðÐ]/g, \"d\").replace(/[ÈÉÊËéèêë]/g, \"e\").replace(/[ÏïÎîÍíÌì]/g, \"i\").replace(/[Ññ]/g, \"n\").replace(/[øØœŒÕõÔôÓóÒò]/g, \"o\").replace(/[ÜüÛûÚúÙù]/g, \"u\").replace(/[ŸÿÝý]/g, \"y\").replace(/[^a-z0-9- ]/gi, \"\").replace(/ /gi, \"-\").toLowerCase();\n}\nfunction zt(t) {\n  return V.test(t) ? \"right\" : q.test(t) ? \"center\" : U.test(t) ? \"left\" : null;\n}\nfunction wt(t, n, e) {\n  const r = e.$;\n  e.$ = !0;\n  const o = n(t.trim(), e);\n  e.$ = r;\n  let c = [[]];\n  return o.forEach(function (t, n) {\n    \"tableSeparator\" === t.type ? 0 !== n && n !== o.length - 1 && c.push([]) : (\"text\" !== t.type || null != o[n + 1] && \"tableSeparator\" !== o[n + 1].type || (t.v = t.v.replace(H, \"\")), c[c.length - 1].push(t));\n  }), c;\n}\nfunction At(t, n, e) {\n  e._ = !0;\n  const r = wt(t[1], n, e),\n    o = t[2].replace(G, \"\").split(\"|\").map(zt),\n    c = function (t, n, e) {\n      return t.trim().split(\"\\n\").map(function (t) {\n        return wt(t, n, e);\n      });\n    }(t[3], n, e);\n  return e._ = !1, {\n    S: o,\n    A: c,\n    L: r,\n    type: \"table\"\n  };\n}\nfunction Et(t, n) {\n  return null == t.S[n] ? {} : {\n    textAlign: t.S[n]\n  };\n}\nfunction Lt(t) {\n  return function (n, e) {\n    return e._ ? t.exec(n) : null;\n  };\n}\nfunction Mt(t) {\n  return function (n, e) {\n    return e._ || e.u ? t.exec(n) : null;\n  };\n}\nfunction Ot(t) {\n  return function (n, e) {\n    return e._ || e.u ? null : t.exec(n);\n  };\n}\nfunction It(t) {\n  return function (n) {\n    return t.exec(n);\n  };\n}\nfunction jt(t, n, e) {\n  if (n._ || n.u) return null;\n  if (e && !e.endsWith(\"\\n\")) return null;\n  let r = \"\";\n  t.split(\"\\n\").every(t => !$t.some(n => n.test(t)) && (r += t + \"\\n\", t.trim()));\n  const o = r.trimEnd();\n  return \"\" == o ? null : [r, o];\n}\nfunction Bt(t) {\n  try {\n    if (decodeURIComponent(t).replace(/[^A-Za-z0-9/:]/g, \"\").match(/^\\s*(javascript|vbscript|data(?!:image)):/i)) return;\n  } catch (t) {\n    return null;\n  }\n  return t;\n}\nfunction Rt(t) {\n  return t.replace(et, \"$1\");\n}\nfunction Tt(t, n, e) {\n  const r = e._ || !1,\n    o = e.u || !1;\n  e._ = !0, e.u = !0;\n  const c = t(n, e);\n  return e._ = r, e.u = o, c;\n}\nfunction Ct(t, n, e) {\n  const r = e._ || !1,\n    o = e.u || !1;\n  e._ = !1, e.u = !0;\n  const c = t(n, e);\n  return e._ = r, e.u = o, c;\n}\nfunction Dt(t, n, e) {\n  return e._ = !1, t(n, e);\n}\nconst Ft = (t, n, e) => ({\n  v: Tt(n, t[1], e)\n});\nfunction Nt() {\n  return {};\n}\nfunction Pt() {\n  return null;\n}\nfunction Zt() {\n  for (var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++) {\n    t[_key] = arguments[_key];\n  }\n  return t.filter(Boolean).join(\" \");\n}\nfunction Gt(t, n, e) {\n  let r = t;\n  const o = n.split(\".\");\n  for (; o.length && (r = r[o[0]], void 0 !== r);) o.shift();\n  return r || e;\n}\nvar Ht;\nfunction qt(e) {\n  let u = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  u.overrides = u.overrides || {}, u.slugify = u.slugify || St, u.namedCodesToUnicode = u.namedCodesToUnicode ? n({}, o, u.namedCodesToUnicode) : o;\n  const G = u.createElement || t.createElement;\n  function H(t, e) {\n    const o = Gt(u.overrides, \"\".concat(t, \".props\"), {});\n    for (var _len2 = arguments.length, r = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      r[_key2 - 2] = arguments[_key2];\n    }\n    return G(function (t, n) {\n      const e = Gt(n, t);\n      return e ? \"function\" == typeof e || \"object\" == typeof e && \"render\" in e ? e : Gt(n, \"\".concat(t, \".component\"), t) : t;\n    }(t, u.overrides), n({}, e, o, {\n      className: Zt(null == e ? void 0 : e.className, o.className) || void 0\n    }), ...r);\n  }\n  function q(n) {\n    let e = !1;\n    u.forceInline ? e = !0 : u.forceBlock || (e = !1 === N.test(n));\n    const r = ct(ot(e ? n : \"\".concat(n.trimEnd().replace(tt, \"\"), \"\\n\\n\"), {\n      _: e\n    }));\n    for (; \"string\" == typeof r[r.length - 1] && !r[r.length - 1].trim();) r.pop();\n    if (null === u.wrapper) return r;\n    const o = u.wrapper || (e ? \"span\" : \"div\");\n    let c;\n    if (r.length > 1 || u.forceWrapper) c = r;else {\n      if (1 === r.length) return c = r[0], \"string\" == typeof c ? H(\"span\", {\n        key: \"outer\"\n      }, c) : c;\n      c = null;\n    }\n    return t.createElement(o, {\n      key: \"outer\"\n    }, c);\n  }\n  function U(n) {\n    const e = n.match(a);\n    return e ? e.reduce(function (n, e, o) {\n      const c = e.indexOf(\"=\");\n      if (-1 !== c) {\n        const a = function (t) {\n            return -1 !== t.indexOf(\"-\") && null === t.match(E) && (t = t.replace(B, function (t, n) {\n              return n.toUpperCase();\n            })), t;\n          }(e.slice(0, c)).trim(),\n          _ = function (t) {\n            const n = t[0];\n            return ('\"' === n || \"'\" === n) && t.length >= 2 && t[t.length - 1] === n ? t.slice(1, -1) : t;\n          }(e.slice(c + 1).trim()),\n          u = r[a] || a,\n          i = n[u] = function (t, n) {\n            return \"style\" === t ? n.split(/;\\s?/).reduce(function (t, n) {\n              const e = n.slice(0, n.indexOf(\":\"));\n              return t[e.replace(/(-[a-z])/g, t => t[1].toUpperCase())] = n.slice(e.length + 1).trim(), t;\n            }, {}) : \"href\" === t ? Bt(n) : (n.match(M) && (n = n.slice(1, n.length - 1)), \"true\" === n || \"false\" !== n && n);\n          }(a, _);\n        \"string\" == typeof i && (z.test(i) || L.test(i)) && (n[u] = t.cloneElement(q(i.trim()), {\n          key: o\n        }));\n      } else \"style\" !== e && (n[r[e] || e] = !0);\n      return n;\n    }, {}) : null;\n  }\n  const V = [],\n    et = {},\n    rt = {\n      blockQuote: {\n        t: Ot(i),\n        i: Ht.HIGH,\n        l: (t, n, e) => ({\n          v: n(t[0].replace(s, \"\"), e)\n        }),\n        h: (t, n, e) => H(\"blockquote\", {\n          key: e.k\n        }, n(t.v, e))\n      },\n      breakLine: {\n        t: It(l),\n        i: Ht.HIGH,\n        l: Nt,\n        h: (t, n, e) => H(\"br\", {\n          key: e.k\n        })\n      },\n      breakThematic: {\n        t: Ot(f),\n        i: Ht.HIGH,\n        l: Nt,\n        h: (t, n, e) => H(\"hr\", {\n          key: e.k\n        })\n      },\n      codeBlock: {\n        t: Ot(p),\n        i: Ht.MAX,\n        l: t => ({\n          v: t[0].replace(/^ {4}/gm, \"\").replace(/\\n+$/, \"\"),\n          M: void 0\n        }),\n        h: (t, e, r) => H(\"pre\", {\n          key: r.k\n        }, H(\"code\", n({}, t.O, {\n          className: t.M ? \"lang-\".concat(t.M) : \"\"\n        }), t.v))\n      },\n      codeFenced: {\n        t: Ot(d),\n        i: Ht.MAX,\n        l: t => ({\n          O: U(t[3] || \"\"),\n          v: t[4],\n          M: t[2] || void 0,\n          type: \"codeBlock\"\n        })\n      },\n      codeInline: {\n        t: Mt(m),\n        i: Ht.LOW,\n        l: t => ({\n          v: t[2]\n        }),\n        h: (t, n, e) => H(\"code\", {\n          key: e.k\n        }, t.v)\n      },\n      footnote: {\n        t: Ot(h),\n        i: Ht.MAX,\n        l: t => (V.push({\n          I: t[2],\n          j: t[1]\n        }), {}),\n        h: Pt\n      },\n      footnoteReference: {\n        t: Lt(k),\n        i: Ht.HIGH,\n        l: t => ({\n          v: t[1],\n          B: \"#\".concat(u.slugify(t[1]))\n        }),\n        h: (t, n, e) => H(\"a\", {\n          key: e.k,\n          href: Bt(t.B)\n        }, H(\"sup\", {\n          key: e.k\n        }, t.v))\n      },\n      gfmTask: {\n        t: Lt(b),\n        i: Ht.HIGH,\n        l: t => ({\n          R: \"x\" === t[1].toLowerCase()\n        }),\n        h: (t, n, e) => H(\"input\", {\n          checked: t.R,\n          key: e.k,\n          readOnly: !0,\n          type: \"checkbox\"\n        })\n      },\n      heading: {\n        t: Ot(u.enforceAtxHeadings ? v : $),\n        i: Ht.HIGH,\n        l: (t, n, e) => ({\n          v: Tt(n, t[2], e),\n          T: u.slugify(t[2]),\n          C: t[1].length\n        }),\n        h: (t, n, e) => H(\"h\".concat(t.C), {\n          id: t.T,\n          key: e.k\n        }, n(t.v, e))\n      },\n      headingSetext: {\n        t: Ot(S),\n        i: Ht.MAX,\n        l: (t, n, e) => ({\n          v: Tt(n, t[1], e),\n          C: \"=\" === t[2] ? 1 : 2,\n          type: \"heading\"\n        })\n      },\n      htmlComment: {\n        t: It(A),\n        i: Ht.HIGH,\n        l: () => ({}),\n        h: Pt\n      },\n      image: {\n        t: Mt(bt),\n        i: Ht.HIGH,\n        l: t => ({\n          D: t[1],\n          B: Rt(t[2]),\n          F: t[3]\n        }),\n        h: (t, n, e) => H(\"img\", {\n          key: e.k,\n          alt: t.D || void 0,\n          title: t.F || void 0,\n          src: Bt(t.B)\n        })\n      },\n      link: {\n        t: Lt(xt),\n        i: Ht.LOW,\n        l: (t, n, e) => ({\n          v: Ct(n, t[1], e),\n          B: Rt(t[2]),\n          F: t[3]\n        }),\n        h: (t, n, e) => H(\"a\", {\n          key: e.k,\n          href: Bt(t.B),\n          title: t.F\n        }, n(t.v, e))\n      },\n      linkAngleBraceStyleDetector: {\n        t: Lt(j),\n        i: Ht.MAX,\n        l: t => ({\n          v: [{\n            v: t[1],\n            type: \"text\"\n          }],\n          B: t[1],\n          type: \"link\"\n        })\n      },\n      linkBareUrlDetector: {\n        t: (t, n) => n.N ? null : Lt(O)(t, n),\n        i: Ht.MAX,\n        l: t => ({\n          v: [{\n            v: t[1],\n            type: \"text\"\n          }],\n          B: t[1],\n          F: void 0,\n          type: \"link\"\n        })\n      },\n      linkMailtoDetector: {\n        t: Lt(I),\n        i: Ht.MAX,\n        l(t) {\n          let n = t[1],\n            e = t[1];\n          return _.test(e) || (e = \"mailto:\" + e), {\n            v: [{\n              v: n.replace(\"mailto:\", \"\"),\n              type: \"text\"\n            }],\n            B: e,\n            type: \"link\"\n          };\n        }\n      },\n      orderedList: kt(H, 1),\n      unorderedList: kt(H, 2),\n      newlineCoalescer: {\n        t: Ot(g),\n        i: Ht.LOW,\n        l: Nt,\n        h: () => \"\\n\"\n      },\n      paragraph: {\n        t: jt,\n        i: Ht.LOW,\n        l: Ft,\n        h: (t, n, e) => H(\"p\", {\n          key: e.k\n        }, n(t.v, e))\n      },\n      ref: {\n        t: Lt(T),\n        i: Ht.MAX,\n        l: t => (et[t[1]] = {\n          B: t[2],\n          F: t[4]\n        }, {}),\n        h: Pt\n      },\n      refImage: {\n        t: Mt(C),\n        i: Ht.MAX,\n        l: t => ({\n          D: t[1] || void 0,\n          P: t[2]\n        }),\n        h: (t, n, e) => H(\"img\", {\n          key: e.k,\n          alt: t.D,\n          src: Bt(et[t.P].B),\n          title: et[t.P].F\n        })\n      },\n      refLink: {\n        t: Lt(D),\n        i: Ht.MAX,\n        l: (t, n, e) => ({\n          v: n(t[1], e),\n          Z: n(t[0].replace(F, \"\\\\$1\"), e),\n          P: t[2]\n        }),\n        h: (t, n, e) => et[t.P] ? H(\"a\", {\n          key: e.k,\n          href: Bt(et[t.P].B),\n          title: et[t.P].F\n        }, n(t.v, e)) : H(\"span\", {\n          key: e.k\n        }, n(t.Z, e))\n      },\n      table: {\n        t: Ot(R),\n        i: Ht.HIGH,\n        l: At,\n        h: (t, n, e) => H(\"table\", {\n          key: e.k\n        }, H(\"thead\", null, H(\"tr\", null, t.L.map(function (r, o) {\n          return H(\"th\", {\n            key: o,\n            style: Et(t, o)\n          }, n(r, e));\n        }))), H(\"tbody\", null, t.A.map(function (r, o) {\n          return H(\"tr\", {\n            key: o\n          }, r.map(function (r, o) {\n            return H(\"td\", {\n              key: o,\n              style: Et(t, o)\n            }, n(r, e));\n          }));\n        })))\n      },\n      tableSeparator: {\n        t: function (t, n) {\n          return n.$ ? (n._ = !0, Z.exec(t)) : null;\n        },\n        i: Ht.HIGH,\n        l: function () {\n          return {\n            type: \"tableSeparator\"\n          };\n        },\n        h: () => \" | \"\n      },\n      text: {\n        t: It(Y),\n        i: Ht.MIN,\n        l: t => ({\n          v: t[0].replace(w, (t, n) => u.namedCodesToUnicode[n] ? u.namedCodesToUnicode[n] : t)\n        }),\n        h: t => t.v\n      },\n      textBolded: {\n        t: Mt(W),\n        i: Ht.MED,\n        l: (t, n, e) => ({\n          v: n(t[2], e)\n        }),\n        h: (t, n, e) => H(\"strong\", {\n          key: e.k\n        }, n(t.v, e))\n      },\n      textEmphasized: {\n        t: Mt(Q),\n        i: Ht.LOW,\n        l: (t, n, e) => ({\n          v: n(t[2], e)\n        }),\n        h: (t, n, e) => H(\"em\", {\n          key: e.k\n        }, n(t.v, e))\n      },\n      textEscaped: {\n        t: Mt(K),\n        i: Ht.HIGH,\n        l: t => ({\n          v: t[1],\n          type: \"text\"\n        })\n      },\n      textMarked: {\n        t: Mt(X),\n        i: Ht.LOW,\n        l: Ft,\n        h: (t, n, e) => H(\"mark\", {\n          key: e.k\n        }, n(t.v, e))\n      },\n      textStrikethroughed: {\n        t: Mt(J),\n        i: Ht.LOW,\n        l: Ft,\n        h: (t, n, e) => H(\"del\", {\n          key: e.k\n        }, n(t.v, e))\n      }\n    };\n  !0 !== u.disableParsingRawHTML && (rt.htmlBlock = {\n    t: It(z),\n    i: Ht.HIGH,\n    l(t, n, e) {\n      const [, r] = t[3].match(nt),\n        o = new RegExp(\"^\".concat(r), \"gm\"),\n        a = t[3].replace(o, \"\"),\n        _ = (u = a, vt.some(t => t.test(u)) ? Dt : Tt);\n      var u;\n      const i = t[1].toLowerCase(),\n        s = -1 !== c.indexOf(i);\n      e.N = e.N || \"a\" === i;\n      const l = s ? t[3] : _(n, a, e);\n      return e.N = !1, {\n        O: U(t[2]),\n        v: l,\n        G: s,\n        H: s ? i : t[1]\n      };\n    },\n    h: (t, e, r) => H(t.H, n({\n      key: r.k\n    }, t.O), t.G ? t.v : e(t.v, r))\n  }, rt.htmlSelfClosing = {\n    t: It(L),\n    i: Ht.HIGH,\n    l: t => ({\n      O: U(t[2] || \"\"),\n      H: t[1]\n    }),\n    h: (t, e, r) => H(t.H, n({}, t.O, {\n      key: r.k\n    }))\n  });\n  const ot = function (t) {\n      let n = Object.keys(t);\n      function e(r, o) {\n        let c = [],\n          a = \"\";\n        for (; r;) {\n          let _ = 0;\n          for (; _ < n.length;) {\n            const u = n[_],\n              i = t[u],\n              s = i.t(r, o, a);\n            if (s) {\n              const t = s[0];\n              r = r.substring(t.length);\n              const n = i.l(s, e, o);\n              null == n.type && (n.type = u), c.push(n), a = t;\n              break;\n            }\n            _++;\n          }\n        }\n        return c;\n      }\n      return n.sort(function (n, e) {\n        let r = t[n].i,\n          o = t[e].i;\n        return r !== o ? r - o : n < e ? -1 : 1;\n      }), function (t, n) {\n        return e(function (t) {\n          return t.replace(y, \"\\n\").replace(x, \"\").replace(P, \"    \");\n        }(t), n);\n      };\n    }(rt),\n    ct = (at = function (t) {\n      return function (n, e, r) {\n        return t[n.type].h(n, e, r);\n      };\n    }(rt), function t(n) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (Array.isArray(n)) {\n        const r = e.k,\n          o = [];\n        let c = !1;\n        for (let r = 0; r < n.length; r++) {\n          e.k = r;\n          const a = t(n[r], e),\n            _ = \"string\" == typeof a;\n          _ && c ? o[o.length - 1] += a : null !== a && o.push(a), c = _;\n        }\n        return e.k = r, o;\n      }\n      return at(n, t, e);\n    });\n  var at;\n  const _t = q(e);\n  return V.length ? H(\"div\", null, _t, H(\"footer\", {\n    key: \"footer\"\n  }, V.map(function (t) {\n    return H(\"div\", {\n      id: u.slugify(t.j),\n      key: t.j\n    }, t.j, ct(ot(t.I, {\n      _: !0\n    })));\n  }))) : _t;\n}\n!function (t) {\n  t[t.MAX = 0] = \"MAX\", t[t.HIGH = 1] = \"HIGH\", t[t.MED = 2] = \"MED\", t[t.LOW = 3] = \"LOW\", t[t.MIN = 4] = \"MIN\";\n}(Ht || (Ht = {}));\nexport default (n => {\n  let {\n      children: r,\n      options: o\n    } = n,\n    c = function (t, n) {\n      if (null == t) return {};\n      var e,\n        r,\n        o = {},\n        c = Object.keys(t);\n      for (r = 0; r < c.length; r++) n.indexOf(e = c[r]) >= 0 || (o[e] = t[e]);\n      return o;\n    }(n, e);\n  return t.cloneElement(qt(r, o), c);\n});\nexport { qt as compiler };\n//# sourceMappingURL=index.modern.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}